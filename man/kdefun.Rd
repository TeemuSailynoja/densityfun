% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kde_fun.R
\name{kdefun}
\alias{kdefun}
\alias{kdefun_adaptive}
\title{Kernel density estimate function}
\usage{
kdefun(
  x,
  bw = "SJ",
  adjust = 1,
  kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight",
    "cosine", "optcosine"),
  weights = NULL,
  na.rm = FALSE,
  fun.type = c("pdf", "cdf"),
  ...
)

kdefun_adaptive(
  x,
  bw = "SJ",
  adjust = 1,
  kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight",
    "cosine", "optcosine"),
  weights = NULL,
  na.rm = FALSE,
  fun.type = c("pdf", "cdf"),
  ...
)
}
\arguments{
\item{x}{the data from which the estimate is to be computed. For the default
method a numeric vector: long vectors are not supported.}

\item{bw}{the smoothing bandwidth to be used. The kernels are scaled such
that this is the standard deviation of the smoothing kernel.

'bw' can also be a character string giving a rule to choose the bandwidth.
See \link[stats]{bw.nrd}.

The specified (or computed) value of 'bw' is multiplied by 'adjust'.}

\item{adjust}{the bandwidth used is actually adjust*bw. This makes it easy to
specify values like ‘half the default’ bandwidth.}

\item{kernel}{a character string giving the smoothing kernel to be used. This
 must partially match one of "gaussian", "rectangular", "triangular",
 "epanechnikov", "biweight", "cosine" or "optcosine", with default
 "gaussian", and may be abbreviated to a unique prefix (single letter).

"cosine" is smoother than "optcosine", which is the usual ‘cosine’ kernel in
the literature and almost MSE-efficient.}

\item{weights}{numeric vector of non-negative observation weights, hence of
same length as 'x'. The default 'NULL' is equivalent to
'weights = rep(1/nx, nx)' where 'nx' is the length of (the finite entries of)
 'x[]'. If 'na.rm = TRUE' and there are NA's in 'x', they and the
 corresponding weights are removed before computations. In that case, when
 the original weights have summed to one, they are re-scaled to keep doing so.}

\item{na.rm}{logical; if TRUE, missing values are removed from x. If FALSE
any missing values cause an error.}

\item{fun.type}{Should a pdf or cdf be returned.}

\item{...}{further arguments for (non-default) methods.}
}
\value{
a function with formal argument y specifying one or more evaluation
points for the pdf of cdf of the computed KDE.
}
\description{
This function is used to obtain a callable KDE function, especially useful,
when the
}
\section{Functions}{
\itemize{
\item \code{kdefun_adaptive}: KDE with adaptive bandwidth. After computing \eqn{ f_0 }, a regular KDE
with bandwith determined by 'bw', each value in `x`, \eqn{ x_i } obtains an individual
bandwidth equal to \eqn{h_i = \sqrt{\frac{\bar{f_0})}{f_0(x_i)}}.}
}}

